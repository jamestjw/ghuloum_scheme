(import (test_driver))

(test-case 5 "5" "Runtime - Simple Fixnum")
(test-case #\a "a" "Runtime - Simple Char (a)")
(test-case #\A "A" "Runtime - Simple Char (A)")
(test-case #t "1" "Runtime - Simple Boolean (#t)")
(test-case #f "0" "Runtime - Simple Boolean (#f)")
(test-case '() "()" "Runtime - Empty List")
(test-case '(add1 5) "6" "Unary Primitive - add1")
(test-exception '(add1 #t) "Unary Primitive - add1 with boolean")
(test-exception '(add1 #\t) "Unary Primitive - add1 with char")
(test-exception '(add1 '()) "Unary Primitive - add1 with empty list")
(test-case '(sub1 5) "4" "Unary Primitive - sub1")
(test-exception '(sub1 #t) "Unary Primitive - sub1 with boolean")
(test-exception '(sub1 #\t) "Unary Primitive - sub1 with char")
(test-exception '(sub1 '()) "Unary Primitive - sub1 with empty list")
(test-case '(integer->char 65) "A" "Unary Primitive - integer->char (65 -> A)")
(test-case '(integer->char 100) "d" "Unary Primitive - integer->char (100 -> d)")
(test-case '(char->integer #\a) "97" "Unary Primitive - char->integer (a -> 97)")
(test-case '(char->integer #\d) "100" "Unary Primitive - char->integer (d -> 100)")
(test-case '(zero? 0) "1" "Unary Primitive - (zero? 0)")
(test-case '(zero? 5) "0" "Unary Primitive - (zero? 5)")
(test-exception '(zero? #t) "Unary Primitive - (zero? #t)")
(test-case '(null? 100) "0" "Unary Primitive - (null? 100)")
(test-case '(null? #t) "0" "Unary Primitive - (null? #t)")
(test-case '(null? #\a) "0" "Unary Primitive - (null? #\\a)")
(test-case '(null? '()) "1" "Unary Primitive - (null? '())")
(test-case '(not #f) "1" "Unary Primitive - (not #f)")
(test-case '(not #t) "0" "Unary Primitive - (not #t)")
(test-case '(not 0) "0" "Unary Primitive - (not 0)")
(test-case '(not #\a) "0" "Unary Primitive - (not #\\a)")
(test-case '(not '()) "0" "Unary Primitive - (not '())")
(test-case '(integer? 5) "1" "Unary Primitive - (integer? 5)")
(test-case '(integer? #t) "0" "Unary Primitive - (integer? #t)")
(test-case '(integer? #\a) "0" "Unary Primitive - (integer? #\\a)")
(test-case '(integer? '()) "0" "Unary Primitive - (integer? '())")
(test-case '(boolean? #t) "1" "Unary Primitive - (boolean? #t)")
(test-case '(boolean? #f) "1" "Unary Primitive - (boolean? #f)")
(test-case '(boolean? 1) "0" "Unary Primitive - (boolean? 1)")
(test-case '(boolean? 0) "0" "Unary Primitive - (boolean? 0)")
(test-case '(boolean? #\a) "0" "Unary Primitive - (boolean? #\\a)")
(test-case '(boolean? '()) "0" "Unary Primitive - (boolean? '())")
(test-case '(char? #\a) "1" "Unary Primitive - (char? #\\a)")
(test-case '(char? #t) "0" "Unary Primitive - (char? #t)")
(test-case '(char? 1) "0" "Unary Primitive - (char? 1)")
(test-case '(char? '()) "0" "Unary Primitive - (char? '())")
(test-case '(lognot 0) "-1" "Unary Primitive - (lognot 0)")
(test-case '(lognot -2) "1" "Unary Primitive - (lognot -2)")
(test-case '(lognot 1) "-2" "Unary Primitive - (lognot 1)")
(test-exception '(lognot #t) "Unary Primitive - (lognot #t)")
(test-exception '(lognot #\a) "Unary Primitive - (lognot #\\a)")
(test-exception '(lognot '()) "Unary Primitive - (lognot '())")
(test-case '(+ 1 2) "3" "Binary Primitive - (+ 1 2)")
(test-case '(+ 1 (+ 2 3)) "6" "Binary Primitive - (+ 1 (+ 2 3))")
(test-case '(- 5 2) "3" "Binary Primitive - (- 5 2)")
(test-case '(- 10 (- 5 3)) "8" "Binary Primitive - (- 10 (- 5 3))")
(test-case '(* 2 3) "6" "Binary Primitive - (* 2 3)")
(test-case '(* 6710886 80) "536870880" "Binary Primitive - * Overflow check")
(test-case '(= 1 2) "0" "Binary Primitive - (= 1 2)")
(test-case '(= 4 4) "1" "Binary Primitive - (= 4 4)")
(test-case '(= #t #t) "1" "Binary Primitive - (= #t #t)")
(test-case '(= #t 5) "0" "Binary Primitive - (= #t 5)")
(test-case '(< 2 3) "1" "Binary Primitive - (< 2 3)")
(test-case '(< 4 3) "0" "Binary Primitive - (< 4 3)")
(test-case '(<= 2 3) "1" "Binary Primitive - (<= 2 3)")
(test-case '(<= 3 3) "1" "Binary Primitive - (<= 3 3)")
(test-case '(<= 4 3) "0" "Binary Primitive - (<= 4 3)")
(test-case '(> 2 3) "0" "Binary Primitive - (> 2 3)")
(test-case '(> 4 3) "1" "Binary Primitive - (> 4 3)")
(test-case '(>= 2 3) "0" "Binary Primitive - (>= 2 3)")
(test-case '(>= 3 3) "1" "Binary Primitive - (>= 3 3)")
(test-case '(>= 4 3) "1" "Binary Primitive - (>= 4 3)")
(test-case '(char=? #\a #\a) "1" "Binary Primitive - (char=? #\\a #\\a)")
(test-case '(char=? #\a #\A) "0" "Binary Primitive - (char=? #\\a #\\A)")
(test-case '(char<? #\d #\e) "1" "Binary Primitive - (char<? #\\d #\\e)")
(test-case '(char<? #\d #\c) "0" "Binary Primitive - (char<? #\\d #\\c)")
(test-case '(char<=? #\d #\e) "1" "Binary Primitive - (char<=? #\\d #\\e)")
(test-case '(char<=? #\e #\e) "1" "Binary Primitive - (char<=? #\\e #\\e)")
(test-case '(char<=? #\f #\e) "0" "Binary Primitive - (char<=? #\\f #\\e)")
(test-case '(char>? #\d #\e) "0" "Binary Primitive - (char>? #\\d #\\e)")
(test-case '(char>? #\f #\e) "1" "Binary Primitive - (char>? #\\f #\\e)")
(test-case '(char>=? #\d #\e) "0" "Binary Primitive - (char>=? #\\d #\\e)")
(test-case '(char>=? #\e #\e) "1" "Binary Primitive - (char>=? #\\e #\\e)")
(test-case '(char>=? #\f #\e) "1" "Binary Primitive - (char>=? #\\f #\\e)")
(test-case '(let ([x 5]) x) "5" "Let (simple)")
(test-case '(let ([x (+ 1 2)]) x) "3" "Let (with +)")
(test-case '(let ([x (+ 1 2)])
              (let ([y (+ 3 4)])
                (+ x y))) "10" "Let (nested +)")
(test-case '(let ([x (+ 1 2)])
              (let ([y (+ 3 4)])
                (- y x))) "4" "Let (nested -)")
(test-case '(let ([x (+ 1 2)] [y (+ 3 4)])
              (- y x)) "4" "Let (multiple bindings)")
(test-case '(let ([x (let ([y (+ 1 2)]) (* y y))])
              (+ x x)) "18" "Let (let in binding)")
(test-case '(let ([x (+ 1 2)])
              (let ([x (+ 3 4)])
                x)) "7" "Let (shadowing in nested lets)")
(test-case '(let ([x (+ 1 2)])
              (let ([x (+ x 4)])
                x)) "7" "Let (access previous vars in nested lets)")
(test-case '(let ([t (let ([t (let ([t (let ([t (+ 1 2)]) t)]) t)]) t)]) t) "3" "Let (many levels of nesting)")
(test-case '(let ([x 12])
              (let ([x (+ x x)])
                (let ([x (+ x x)])
                  (let ([x (+ x x)])
                    (+ x x))))) "192" "Let (many levels of nesting v2)")