(import (test_driver))

(test-case 5 "5" "Runtime - Simple Fixnum")
(test-case #\a "a" "Runtime - Simple Char (a)")
(test-case #\A "A" "Runtime - Simple Char (A)")
(test-case #t "1" "Runtime - Simple Boolean (#t)")
(test-case #f "0" "Runtime - Simple Boolean (#f)")
(test-case '() "()" "Runtime - Empty List")
(test-case '(add1 5) "6" "Unary Primitive - add1")
(test-case '(sub1 5) "4" "Unary Primitive - sub1")
; TODO: Make this work
; (test-exception '(add1 #t) "Unary Primitive - add1 with boolean")
; (test-exception '(add1 #\t) "Unary Primitive - add1 with char")
; (test-exception '(add1 '()) "Unary Primitive - add1 with empty list")
; (test-exception '(sub1 #t) "Unary Primitive - sub1 with boolean")
; (test-exception '(sub1 #\t) "Unary Primitive - sub1 with char")
; (test-exception '(sub1 '()) "Unary Primitive - sub1 with empty list")
(test-case '(integer->char 65) "A" "Unary Primitive - integer->char (65 -> A)")
(test-case '(integer->char 100) "d" "Unary Primitive - integer->char (100 -> d)")
(test-case '(char->integer #\a) "97" "Unary Primitive - char->integer (a -> 97)")
(test-case '(char->integer #\d) "100" "Unary Primitive - char->integer (d -> 100)")
(test-case '(zero? 0) "1" "Unary Primitive - (zero? 0)")
(test-case '(zero? 5) "0" "Unary Primitive - (zero? 5)")
(test-exception '(zero? #t) "Unary Primitive - (zero? #t)")
(test-case '(null? 100) "0" "Unary Primitive - (null? 100)")
(test-case '(null? #t) "0" "Unary Primitive - (null? #t)")
(test-case '(null? #\a) "0" "Unary Primitive - (null? #\\a)")
(test-case '(null? '()) "1" "Unary Primitive - (null? '())")
(test-case '(not #f) "1" "Unary Primitive - (not #f)")
(test-case '(not #t) "0" "Unary Primitive - (not #t)")
(test-case '(not 0) "0" "Unary Primitive - (not 0)")
(test-case '(not #\a) "0" "Unary Primitive - (not #\\a)")
(test-case '(not '()) "0" "Unary Primitive - (not '())")
(test-case '(integer? 5) "1" "Unary Primitive - (integer? 5)")
(test-case '(integer? #t) "0" "Unary Primitive - (integer? #t)")
(test-case '(integer? #\a) "0" "Unary Primitive - (integer? #\\a)")
(test-case '(integer? '()) "0" "Unary Primitive - (integer? '())")
(test-case '(boolean? #t) "1" "Unary Primitive - (boolean? #t)")
(test-case '(boolean? #f) "1" "Unary Primitive - (boolean? #f)")
(test-case '(boolean? 1) "0" "Unary Primitive - (boolean? 1)")
(test-case '(boolean? 0) "0" "Unary Primitive - (boolean? 0)")
(test-case '(boolean? #\a) "0" "Unary Primitive - (boolean? #\\a)")
(test-case '(boolean? '()) "0" "Unary Primitive - (boolean? '())")
(test-case '(char? #\a) "1" "Unary Primitive - (char? #\\a)")
(test-case '(char? #t) "0" "Unary Primitive - (char? #t)")
(test-case '(char? 1) "0" "Unary Primitive - (char? 1)")
(test-case '(char? '()) "0" "Unary Primitive - (char? '())")
(test-case '(lognot 0) "-1" "Unary Primitive - (lognot 0)")
(test-case '(lognot -2) "1" "Unary Primitive - (lognot -2)")
(test-case '(lognot 1) "-2" "Unary Primitive - (lognot 1)")
(test-exception '(lognot #t) "Unary Primitive - (lognot #t)")
(test-exception '(lognot #\a) "Unary Primitive - (lognot #\\a)")
(test-exception '(lognot '()) "Unary Primitive - (lognot '())")
(test-case '(+ 1 2) "3" "Binary Primitive - (+ 1 2)")
(test-case '(+ 1 (+ 2 3)) "6" "Binary Primitive - (+ 1 (+ 2 3))")
(test-case '(- 5 2) "3" "Binary Primitive - (- 5 2)")
(test-case '(- 10 (- 5 3)) "8" "Binary Primitive - (- 10 (- 5 3))")
(test-case '(* 2 3) "6" "Binary Primitive - (* 2 3)")
(test-case '(* 6710886 80) "536870880" "Binary Primitive - * Overflow check")
(test-case '(= 1 2) "0" "Binary Primitive - (= 1 2)")
(test-case '(= 4 4) "1" "Binary Primitive - (= 4 4)")
(test-case '(= #t #t) "1" "Binary Primitive - (= #t #t)")
(test-case '(= #t 5) "0" "Binary Primitive - (= #t 5)")
(test-case '(< 2 3) "1" "Binary Primitive - (< 2 3)")
(test-case '(< 4 3) "0" "Binary Primitive - (< 4 3)")
(test-case '(<= 2 3) "1" "Binary Primitive - (<= 2 3)")
(test-case '(<= 3 3) "1" "Binary Primitive - (<= 3 3)")
(test-case '(<= 4 3) "0" "Binary Primitive - (<= 4 3)")
(test-case '(> 2 3) "0" "Binary Primitive - (> 2 3)")
(test-case '(> 4 3) "1" "Binary Primitive - (> 4 3)")
(test-case '(>= 2 3) "0" "Binary Primitive - (>= 2 3)")
(test-case '(>= 3 3) "1" "Binary Primitive - (>= 3 3)")
(test-case '(>= 4 3) "1" "Binary Primitive - (>= 4 3)")
(test-case '(char=? #\a #\a) "1" "Binary Primitive - (char=? #\\a #\\a)")
(test-case '(char=? #\a #\A) "0" "Binary Primitive - (char=? #\\a #\\A)")
(test-case '(char<? #\d #\e) "1" "Binary Primitive - (char<? #\\d #\\e)")
(test-case '(char<? #\d #\c) "0" "Binary Primitive - (char<? #\\d #\\c)")
(test-case '(char<=? #\d #\e) "1" "Binary Primitive - (char<=? #\\d #\\e)")
(test-case '(char<=? #\e #\e) "1" "Binary Primitive - (char<=? #\\e #\\e)")
(test-case '(char<=? #\f #\e) "0" "Binary Primitive - (char<=? #\\f #\\e)")
(test-case '(char>? #\d #\e) "0" "Binary Primitive - (char>? #\\d #\\e)")
(test-case '(char>? #\f #\e) "1" "Binary Primitive - (char>? #\\f #\\e)")
(test-case '(char>=? #\d #\e) "0" "Binary Primitive - (char>=? #\\d #\\e)")
(test-case '(char>=? #\e #\e) "1" "Binary Primitive - (char>=? #\\e #\\e)")
(test-case '(char>=? #\f #\e) "1" "Binary Primitive - (char>=? #\\f #\\e)")
(test-case '(let ([x 5]) x) "5" "Let (simple)")
(test-case '(let ([x (+ 1 2)]) x) "3" "Let (with +)")
(test-case '(let ([x (+ 1 2)])
              (let ([y (+ 3 4)])
                (+ x y))) "10" "Let (nested +)")
(test-case '(let ([x (+ 1 2)])
              (let ([y (+ 3 4)])
                (- y x))) "4" "Let (nested -)")
(test-case '(let ([x (+ 1 2)] [y (+ 3 4)])
              (- y x)) "4" "Let (multiple bindings)")
(test-case '(let ([x (let ([y (+ 1 2)]) (* y y))])
              (+ x x)) "18" "Let (let in binding)")
(test-case '(let ([x (+ 1 2)])
              (let ([x (+ 3 4)])
                x)) "7" "Let (shadowing in nested lets)")
(test-case '(let ([x (+ 1 2)])
              (let ([x (+ x 4)])
                x)) "7" "Let (access previous vars in nested lets)")
(test-case '(let ([t (let ([t (let ([t (let ([t (+ 1 2)]) t)]) t)]) t)]) t) "3" "Let (many levels of nesting)")
(test-case '(let ([x 12])
              (let ([x (+ x x)])
                (let ([x (+ x x)])
                  (let ([x (+ x x)])
                    (+ x x))))) "192" "Let (many levels of nesting v2)")
(test-case '(let* ([x 1])
              (let* ([x (+ x 1)] [y (+ x 1)])
                y)) "3" "Let*")
(test-case '(if #t 12 13) "12" "If (simple)")
(test-case '(if #f 12 13) "13" "If (simple)")
(test-case '(if 0 12 13) "12" "If (all numbers are truthy)")
(test-case '(if '() 42 '()) "42" "If (empty list is truthy)")
(test-case '(if #t (if 12 13 4) 17) "13" "If (nested)")
(test-case '(if #f 12 (if #f 13 4)) "4" "If (nested)")
(test-case '(if #\X (if 1 2 3) (if 4 5 6)) "2" "If (chars are truthy)")
(test-case '(if (not (boolean? #t)) 15 (boolean? #f)) "1" "If (complex with not & boolean?)")
(test-case '(if (if (char? #\a) (boolean? #\b) (integer? #\c)) 119 -23) "-23" "If (nested with primitive calls)")
(test-case '(if (if (if (not 1) (not 2) (not 3)) 4 5) 6 7) "6" "If (nested)")
(test-case '(if (not (if (if (not 1) (not 2) (not 3)) 4 5)) 6 7) "7" "If (nested)")
(test-case '(not (if (not (if (if (not 1) (not 2) (not 3)) 4 5)) 6 7)) "0" "If (nested with not)")
(test-case '(if (char? 12) 13 14) "14" "If (simple with char?)")
(test-case '(if (char? #\a) 13 14) "13" "If (simple with char?)")
(test-case '(add1 (if (sub1 1) (sub1 13) 14)) "13" "If (with add1 & sub1)")
(test-case '(cons 3 6) "(3 . 6)" "Cons (simple)")
(test-case '(car (cons 3 6)) "3" "Cons (car with int)")
(test-case '(cdr (cons 3 6)) "6" "Cons (cdr with int)")
(test-case '(cons 1 (cons 3 6)) "(1 . (3 . 6))" "Cons (nested)")
(test-case '(car (cons 1 (cons 3 6))) "1" "Cons (car with another pair)")
(test-case '(cdr (cons 1 (cons 3 6))) "(3 . 6)" "Cons (cdr with another pair)")
(test-case '(cons (cons 1 2) (cons 3 4)) "((1 . 2) . (3 . 4))" "Cons (doubly nested)")
(test-case '(let ([x (cons (cons 1 2) (cons 3 4))]) (car (cdr x))) "3" "Cons (doubly nested with cadr)")
(test-case '(cons 5 (cons (cons 1 2) (cons 3 4))) "(5 . ((1 . 2) . (3 . 4)))" "Cons (triply nested)")
(test-case '(cons (cons 5 (cons (cons 1 2) (cons 3 4))) 6) "((5 . ((1 . 2) . (3 . 4))) . 6)" "Cons (quadruply nested)")
(test-case '(make-vector 5 #\a) "#(a a a a a)" "Vector (simple)")
(test-case '(vector? (make-vector 4 #t)) "1" "Vector (vector?)")
